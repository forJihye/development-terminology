# 개발 용어
개발 용어 정리와 개념 설명

## 호이스팅
> 호이스팅의 개념     
함수 안에 있는 선언들을 모두 해당 함수 유효 범위의 최상단으로 끌어올려 선언하는것을 말한다.

### 호이스팅이란
* 자바스크립트 함수는 실행 되기 전 함수 안에 필요한 변수들을 모두 모아서 **함수 유효 범위** 최상단으로 끌어올려서 선언한다.
* 자바스크립트 파서가 함수가 실행되기 전 함수 내부를 한 번 훑어서 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 할당한다.
* **함수 유효 범위** 함수 블록 {} 안에서 유효

### 호이스팅 대상자
* var 변수 선언과, 함수 선언문에서만 호이스팅이 일어난다.
* var 변수와 함수 선언문만 위로 끌어올려지고 **할당**을 끌어올려지지 않는다
* let, const 변수 선언과, 함수 표현식은 호이스팅이 발생되지 않는다.

### 호이스팅 예제
```js
function hoisting(){
  var a = inner();

  console.log(typeof a);
  console.log(a);

  function inner(){
    return 'inner value'
  }
  /** 내부 호이스팅 결과
   * var a;
   * function inner(){
   *  retunr 'inner value'
   * }
   * a = inner();
   * console.log(typeof a)
   * console.log(a)
   * 
   * */
}

for (var i = 0; i < 5; i++) setTimeout(() => console.log(i)) 
/**
 * 5
 * 5
 * 5
 * 5
 * 5
 * for문 동기, setTimeout 비동기 - var i 가 전역변수로 선언되어서 for문 먼저 실행되면서 var i 값 5로 변경되고, 그다음 settimout이 실행된다.
 **/

for (var i = 0; i < 5; i++) setTimeout((i) => console.log(i), 0, i);
```
```js
a 
var a;
// undefined

b 
let b;
// VM263:1 Uncaught ReferenceError: b is not defined
```

-----

## 스코프
### 스코프란?
스코프는 우리말로 번역하면 `범위`라는 뜻이다.     
즉 변수에 접근할 수 있는 범위({})를 뜻한다. (유효범위)

### 스코프 타입
스코프에는 전역(global), 지역(local) 스코프가 있다.     
변수가 전역 스코프에 선언되어 있으면 어디서든 해당 변수에 접근 할 수 있다.     
지역 스코프는 해당 지역 범위에서 선언된 변수만 접근할 수 있으며, 다른 곳에서는 접근 할 수 없다.

-----

## 어휘 스코프 (Lexical Scope)
### 어휘 스코프란? 
함수를 호출 할 때, 호출한 위치가 아닌 선언 된 위치(스코프)에서 참조할 수 있는 변수를 사용하는 방식이다.       

함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 것이다. 여기서 중요한 점은 함수를 호출 할 때가 아니라 **선언**에 따라 결정된다.     
코드가 적힌 순간 변수의 유효범위가 정해지는데 이것을 정적 유효범위 (정의된 시점에서의 유효범위)

### 어휘 스코프 예제
```js
var number = 1;
function a(){
  var number = 10;
  b();
}
function b(){
  console.log(number) // 선언한 순간 number의 유효범위는 전역 스코프로 정해짐
}
a(); // 1
b(); // 1
```
b() 함수 안의 number는 a() 함수 안의 지역변수 number가 아니라 전역변수 number를 가리킵니다.     
함수를 처음 선언하는 순간, 함수 내부의 변수는 자기 스코프로부터 가장 가까운 곳에(상위 스코프)에 있는 변수를 계속 참고하게 됩니다. 위의 예시에서는 b 함수 안의 number는 선언 시 가장 가까운 전역 변수 number를 참조하게 됩니다. 그래서 a 함수에서 b 함수를 호출해도 number 변수가 a 함수의 지역변수 number가 아니라 그대로 전역번수 number 값이 나옵니다.

-----

## 동적 스코프 (다이나믹 스코프)
함수 호출한 위치를 변수를 참조 할 스코프로 결정하는 방식

-----

## 자유변수
자유 변수라는 용어는 지역변수 나 해당 함수의 매개변수가 아닌 함수 에서 사용되는 변수를 나타냅니다.     
스코프 범위 (자기 스코프 제외) 에서 참조 할 수 있는 변수를 자유변수 (부모 스코프에서 참조 가능한 변수, 전역변수)

-----

## 일급 객체 함수 (first-class functions)
> 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 보통 함수에 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체 - 위키백과
일급 객체의 조건은 1. 변수에 할당할 수 있다.(함수 표현식) 
일급 객체 결과 1. 다른 함수를 인자로 전달 받는다. 2. 다른 함수의 결과로서 리턴 될 수 있다.
함수를 데이터(string, number, boolean, array, object...) 다루듯이 다룰 수 있다. 

-----

## 고계함수(고차함수) (higher-order-functions)
함수를 매개변수로 받거나 함수를 리턴하는 함수를 말한다.

### 일급 객체&고계함수 예제
```js
function sum(number){
  return number+number
}
function resultSum(f, number){
  return f(number);
}
const result = resultSum(sum, 10);
```

-----

## 클로저
일급 객체 함수의 개념을 이용하여 함수 스코프에 묶인 변수(자유변수)를 참조, 할당 하기 위한 일종의 기술이다. (자유변수랑 자유변수를 사용하는 함수를 묶는 기술)      
클로저 기술을 사용하는 함수도 클로저라고 칭한다. (자유변수를 참조하는 함수)
> 일급 객체 함수란? 함수에 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라고 한다.

-----

## 의존성 주입 (DI)
### 의존성이란?
```js
class App {
  coffee;
  constructor(){
    this.coffee = new Coffee();
  }
  drinking(){
    this.coffee.drink();
  }
}
```

위 코드를 보면 `App` 클래스에서 `drinking` 함수를 호출하기 위해선 `Coffee` 클래스가 필요로 한다.     
이것을 **App 클래스는 Coffee 클래스의 의존성을 가진다** 라고 한다. 위와 같이 코드가 설계되었을 때 `Coffee` 클래스가 수정되었을 때 `App` 클래스도 함께 수정해줘야 하는 문제가 발생된다. 결합도(coupling) 즉 의존도가 높아지게 된다.     
또 Coffee 클래스의 상속을 받아 다른 클래스를 사용해야 한다면 `App` 클래스 안에서 직접 다른 클래스로 수정해야 한다.

### 의존성 주입 이용
> 하나의 객체가 다른 객체의 의존성을 제공하는 테크닉이다.

[TypeScript와 typedi로 의존성 주입 이해하기](https://medium.com/@HoseungJang/typescript%EC%99%80-typedi%EB%A1%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-5d83ef1977f9)

**의존성**은 예를 들어 서비스로 사용할 수 있는 객체이다. 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, <U>클라이언트에게 무슨 서비스를 사용할 것인지를 말해주는 것.</U>     
**주입**은 의존성(서비스)를 사용하는 객체(클라이언트)로 전달하는 것     

의존성 주입의 의도는 객체의 생성과 사용을 분리하여 가독성과 코드 재사용을 높혀준다. 어떤 서비스를 호출하려는 클라이언트는 그 서비스가 어떻게 구성되었는지 알지 못해야 한다.

```js
class App {
  coffee;
  constructor(coffee){
    this.coffee = coffee;
  }
  drinking(){
    this.coffee.drink();
  }
}
```
위와 같이 의존하는(필요한) 클래스를 직접 생성하는 것이 아닌 생성자로 주입시켜서 객체 간의 결함도(의존도)를 줄이고 좀 더 유연한 코드로 작성할 수 있다.
**한 클래스를 수정했을 때, 다른 클래스로 수정해야하는 상황**을 막아줄 수 있다.

-----

## 자료구조
> 지료 구조는 데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미한다. 

* 대량의 데이터를 효율적으로 관리할 수 있는 데이터의 구조를 의미한다.
* 코드 상에서 효율적으로 데이터를 처리하기 위해, 데이터 특성에 따라 체계적으로 데이터를 구조화해야함      
_(어떤 데이터 구조를 사용하느냐에 따라, 코드 효율이 달라짐)_

구현
1. 배열
2. 튜플
3. 링크드 리스트
4. 원형 링크드 리스트
5. 이중 링크드 리스트
6. 해시 테이블

선형 구조 형태
1. 스택
2. 큐
3. 덱

----- 

> 큐와 스택은 객체와 그 객체가 저장되는 순서를 기억하는 방법에 관한 추상 자료형이다.

## 큐 (자료구조)
> 큐(queue)는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말한다. 영어 단어 queue는 표를 사러 일렬로 늘어선 사람들로 이루어진 줄을 말하기도 하며, 먼저 줄을 선 사람이 먼저 나갈 수 있는 상황을 연상하면 된다. 나중에 집어 넣은 데이터가 먼저 나오는 스택과는 반대되는 개념이다.

[개념정리 참고 사이트](https://atoz-develop.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%81%90-%EC%A0%95%EB%A6%AC-%EB%B0%8F-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C)

* 가장 먼저 입력된 자료가 가장 먼저 출력되는 (선입선출) 관게
* 한쪽 끝에선 삽입 연산만, 다른 한쪽 끝에선 삭제 연산만 발생
* **front**는 큐의 **삭제**가 발생하는 지점
* **rear**는 큐의 **삽입**이 발생하는 지점
_삽입 시 rear를 증가시키고 삭제 시 front를 감소시킨다_

### 큐 연산 수행
```
1. createQueue(4);
2. addQueue(queue, 'A');
3. addQueue(queue, 'B');
4. addQueue(queue, 'C');
5. deleteQueue(queue);
6. deleteQueue(queue);
7. deleteQueue(queue);
8. addQueue(queue, 'D');
```
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FvzzxZ%2FbtqzT5FVUgH%2FgMa6tov6nWjoLWThMdwATK%2Fimg.png" width="300" />

> 7번과 같이 rear 포인터와 front 포인터가 같은 장소를 가리키면(=같은 값이면) 큐는 empty 빈 상태이다.

### 큐의 활용 예시
* 우선순위가 같은 작업 예약 (프린터의 인쇄 대기열)
* 은행 업무
* 프로세스 관리
* 너비 우선 탐색 (BFS) 구현
-----

## 스택
> 스택(stack)은 제한적으로 접근할 수 있는 나열 구조이다. 그 접근 방법은 언제나 목록의 끝에서만 일어난다. 스택은 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조로 되어있다. 자료를 넣는 것을 push라 하고 빼내는 것을 pop이라고 한다. 가장 늦게 푸쉬한 자료가 먼저 나오게된다.

스택은 **쌓아 올린다는 것**을 의미한다.     
따라서 스택 자료구조라는 것은 책을 쌓는 것처럼 **차곡차곡 쌓아 올린 형태의 자료구조**를 말한다.

[개념 정리 문서 참고](https://atoz-develop.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9D-%EC%A0%95%EB%A6%AC-%EB%B0%8F-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C)
* **같은 구조와 크기의 자료를 정해진 방향**으로 쌓을 수 있다.
* 가장 늦게 입력된 자료가 가장 먼저 출력되는 (후입선출) 관계
* 하나의 스택 포인터 변수(일반적으로 top)를 사용
* top은 스택의 **삽입과 삭제가 일어나는 지점**     
_삽입 시 top을 **중가** 시키고 삭제 시 **감소**시킨다_
* **top으로 정한 곳을 통해서만 접근**이 가능

### 스택 연산 수쟁
```
1. CreateStack(3);
2. Push(stack, 'S');
3. Push(stack, 'T');
4. Pop(stack);
5. Push(stack, 'R');
6. Push(stack, 'P');
7. Push(stack, 'Q');
8. Pop(stack);
```
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcMXQ8R%2FbtqzQUFcUEK%2FhBb48GWFHWL3GKVb5YUVPk%2Fimg.png" width="300" />

### 스택의 활용 예시
* 웹 브라우저 방문기록 (뒤로가기): 가장 나중에 열린 페이지부터 다시 보여준다.
* 역순 문자열 만들기: 가장 나중에 입력된 문자부터 출력한다.
* 실행 취소(undo): 가장 나중에 실행된 것부터 실행을 취소한다.

-----

## 링크드 리스트 (연결 리스트)
> 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조이다. 이름에서 말하듯이 데이터를 담고 있는 노드들이 연결되어 있는데, 노드의 포인터가 다음이나 이전의 노드와의 연결을 담당하게 된다.

> 어떤 데이터 덩어리(노드)를 저장할 때 그 다음 순서의 자료가 있는 위치를 데이터에 포함시키는 방식으로 자료를 저장한다. 예를 들어 한 반에 있는 학생들의 자료를 저장한다면, 학생 하나하나의 신상정보 자료를 노드로 만들고 1번 학생의 신상정보 자료에 2번 학생 신상정보가 어디에 있는지 표시를 해 놓는 방식. 즉 비엔나 소시지마냥 줄줄이 엮어놓은 것이다.

<img src="https://w.namu.la/s/ef210f7b01f17258cc7060ba5b02e5b4b337bfb282cea34ac6a68c00ca740eea089b57d84f3f618e103bf8e54b2c698e1290d7bb489498073458f06da004e66469b107ef45900d3ad38946063c9e41c8cf8602641eb7bc76c09f94d9c2ed36161dde5d311e1b56dc3e522b5bd0f284bb" width="150" />

* 연결 리스트는 **포인터 변수**를 이용한다. 즉. 포인터(노드 메모리 주소) 변수를 이용해 구현된 리스트를 연결 리스트라고 한다.
* **포인터 변수**: 다음 원소를 가리키는 위치 저장
* 포인터 변수와 동적 메모리 할당을 이용해 메모리 낭비를 막을 수 있다.
* 링크드 리스트는 포인터 주소만 알아도 데이터를 알 수 있다.
### 포인터를 이용한 리스트
> 연결 리스트에는 노드(Node) 개념을 사용한다. 노드는 데이터를 갖고있는 데이터 필드와 리스트의 다음 원소를 가리키는, 즉 다음 노드의 주소를 갖고있는 포인터로 구성된다.
 
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc7H3Y5%2FbtqzT50fEJF%2FTH3Mk6T2bOHYssAVOiD78K%2Fimg.png" width="500" />

위 그림처럼 연결 리스트로 표현하면 `1919 -> 1945 -> 1950 -> 1998`의 순서를 갖는다.     
그림은 추상화한 연결 리스트의 표현이며 각 노드가 저장된 메모리의 물리적인 주소는 순서에 상관없이 저장된다.

### 배열과 링크드 리스트의 장단점
> 배열은 순서대로 자료 조회를 하기 때문에 (읽는)속도가 빠르고 (필터링이나 검색, 순회 속도가 빠르다), 링크드 리스트는 연결된 포인터 주소로 자료를 조회하기 때문에 읽는 속도가 배열보다 느리다. 링크드 리스트는 자료를 (중간에서도) 추가/삭제 하는 속도는 훨씬 빠르다. (포인터 주소만 찾아서 추가/삭제를 할 수 있기 때문에)

### 예제 (포인터로 가능한 함수)
```c
#include <stdio.h>
void change(int *a) {
    *a = 3;
}
int main()
{
    int val = 10;
    change(&val);
    printf("%d", val); // 3
    return 0;
}
```
1. change 함수에서 매개변수 a를 전달받아 3으로 할당
2. 변수 val에 10 저장
3. change 함수 매개변수로 val 전달
4. 변수 val 값 확인

change 함수에서 val를 `&val` 으로 넣었는데 **&** 은 val의 메모리 주소가 change 매개변수로 전달되고 `*a`는 메모리 주소를 전달받겠다는 의미이다.
chnage 함수에서는 `*a = 3`으로 val의 메모리 주소에 저장되어있는 10이라는 값을 3으로 변경 한 것이다.

## 크리티컬 섹션 (싱크로라이즈)
> 크리티컬 : 치명적인

크리티컬 섹션을 설정한 구간은 한 번의 하나의 `스레드`에서만 사용이 가능하다.     
프로세스 내에 여러 스레드가 있는 환경에서 우리가 설정해둔 `크리티컬 섹션`에 어떤 스레드가 먼저 진입하여 크리티컬 영역을 벗어나지 않은 상태에서는 동일 프로세스의 다른 스레드에서 해당 크리티컬 영역에 **진입하는 것을 금지한다**    

후발 스레드의 크리티컬 섹션 진입금지 방식에는 **리턴**과 **대기**를 설정할 수 있다.     
**대기** 이란 진입한 스레드가 해당영역을 벗어 날 때까지 후발 스레드는 **대기**상태로 있다가 선진입한 스레드가 해당영역을 벗어나면 대기중인 후발 스레드가 크리티컬 영역을 실행한다.     
**리턴** 이란 후발 스레드가 **대기**상태에 있지 않고 **리턴**되어 크리티컬 영역을 실행하지 않는 방식이다.


### 크리티컬 섹션이 사용되는 상황
* 예약 시스템     
자리를 예약하는 상황에서 10명의 사람이 5번 자리 예약 요청을 했을 때, 10명 중 요청이 먼저 들어온 사람이 에약을 완료할 때 까지 기다렸다가 예약완료가 되면 예약 요청한 나머지 9명에게 예약 실패가 되어야한다.

## Saga 패턴
> 비동기 작업이 동시에 실행 될 때 여러 작업 중 하나의 작업이 실패가 되면 나머지 작업들이 성공을 했더라도 모든 작업을 취소 시키는 패턴이다.

_중요한 부분은 취소되는 작업도 같이 있어야만 취소 할 수 있다_

### 패턴 사용 상황
* 외부 서버를 여러개 이용할 때     
해시스냅 이벤트 서버로 당첨 요청을 보내서 나온 당첨 결과에 맞는 이미지를 사용할 때, 이미지를 가져오는 서버가 잘못되서 오류가 나서 이미지를 가져오지 못하는 상황이면 이벤트 서버에서 당첨 결과를 다시 되돌려 줘야한다.     

* 자바스크립트
엄청 큰 이미지 여러개랑 비디오 여러개를 사용해서 순서 상관없이 동시에 그린다고 할때, 그 중 하나의 이미지가 실패해서 그리지 못하는 상황이 되어 에러페이지가 표시된다. 
request는 XHR이나 Fetch나 Axios를 사용하는데 실패되서 에러페이지가 나오는 상황에서는 UI에 부담되지 않게 request를 모두 취소해야합니다.
(해당 객체(XHR, Fetch, Axios)들은 취소를 위한 메소드를 가지고 있다.)

## Promise.all 과 트랜잭션의 차이점
* Promise.all     
여러 비동기 작업들이 성공하면 프로미스가 해소된다. 만약 여러 작업 중 하나의 비동이 작업이 실패되었을 때 프로미스가 취소되지만 **성공한 비동기 작업을 그 성공한 상태를 유지하고 있다.**

* 트랜잭션     
프로미스와 만찬가지로 여러 비동기 작업들이 수행되는데, **하나의 비동이 작업이 실패되면 성공한 작업도 작업이 업데이트 되기 전 상황으로 돌려버린다.**